#this script is used to fit the full SP2 scattering signal of real particles 
#when run for non-incandescent reals this gives a set of data that can be used to set the fixed LEO fit parameters (width and centre position) over time


import sys
import os
import datetime
import pickle
import numpy as np
import matplotlib.pyplot as plt
from pprint import pprint
from scipy.optimize import curve_fit
from scipy import stats
from SP2_particle_record_UTC import ParticleRecord
from struct import *
import hk_new
import hk_new_no_ts_LEO
from scipy import linspace, polyval, polyfit, sqrt, stats
import math
import mysql.connector
from datetime import datetime



#setup
data_dir =  'D:/2012/WHI_UBCSP2/Binary/test/' #'D:/2015/NETCARE_UBC_SP2/flight data/'  #'D:/2010/WHI_ECSP2/Binary/' #'D:/2009/WHI_ECSP2/Binary/'# 'D:/2010/WHI_ECSP2/Binary/'  #'D:/2012/WHI_UBCSP2/Binary/' 
instrument = 'UBCSP2' #'UBCSP2' #ECSP2
instrument_locn = 'WHI'
type_particle = 'nonincand' #nonincand, incand, Aquadag
start_analysis_at = datetime(2012,7,20)
end_analysis_at = 	datetime(2012,7,30)
num_records_to_analyse ='all'
show_full_fit = False

#lookup file
lookup_file = 'C:/Users/Sarah Hanna/Documents/Data/WHI long term record/lookup files/Nonincand_lookup_table_WHI_2012_UBCSP2-used_factor225.lupckl'
lookup = open(lookup_file, 'r')
lookup_table = pickle.load(lookup)
lookup.close()	
scat_amps = sorted(lookup_table.keys())


#pararmeters used to reject invalid particle records based on scattering peak attributes
min_peakheight = 30
max_peakheight = 3700
min_peakpos = 10
max_peakpos = 160

record_size_bytes = 1498 #size of a single particle record in bytes(UBC_SP2 = 1498, EC_SP2 in 2009 and 2010 = 2458)

#database connection
cnx = mysql.connector.connect(user='root', password='Suresh15', host='localhost', database='black_carbon')
cursor = cnx.cursor()

add_data = ('INSERT INTO whi_calibration_data'
            '(sp2b_file, file_index, instrument, instrument_locn, particle_type,UNIX_UTC_ts,actual_scat_amp,FF_scat_amp,FF_peak_posn,FF_gauss_width,actual_zero_x_posn,particle_dia)'
            'VALUES (%(sp2b_file)s,%(file_index)s,%(instrument)s,%(instrument_locn)s,%(particle_type)s,%(UNIX_UTC_ts)s,%(actual_scat_amp)s,%(FF_scat_amp)s,%(FF_peak_posn)s,%(FF_gauss_width)s,%(zero_crossing_pt)s,%(particle_dia)s)')
							

#**********parameters dictionary**********
parameters = {
'acq_rate': 5000000,
}

def find_nearest(array,value):   #get index of value in array closest to value
	idx = (np.abs(array-value)).argmin()
	return idx
	
def gaussFullFit(parameters_dict):
	
	
	#*******HK ANALYSIS************ 

	#####comment this out if it's been run once
	
	####use for hk files with no timestamp (just time since midnight) (this should work for the EC polar flights in spring 2012,also for ECSP2 for WHI 20100610 to 20100026, UBCSP2 prior to 20120405)
	#avg_flow = hk_new_no_ts_LEO.find_bad_hk_durations_no_ts(parameters) 
	#parameters['avg_flow'] = avg_flow
	#bad_durations = []

	##use for hk files with timestamp (this is for the UBCSP2 after 20120405)
	#avg_flow = hk_new.find_bad_hk_durations(parameters)  #writes bad durations in UTC
	#parameters['avg_flow'] = avg_flow


	#*************LEO routine************
	
	
	for file in os.listdir('.'):
		
		if file.endswith('.sp2b'):
			
			print file
			
			path = parameters['directory'] + '/' + str(file)
			file_bytes = os.path.getsize(path) #size of entire file in bytes
			record_size = record_size_bytes  
			number_of_records = (file_bytes/record_size)-1
			if num_records_to_analyse == 'all':
				number_records_toshow =  number_of_records 
			else:
				number_records_toshow = num_records_to_analyse    
			
			##************This is the full-gauss prefit************
			
			f = open(file, 'rb')
			
			#grab the pickled bad_durations file generated by the HK analysis
			for hk_file in os.listdir('.'):
				if hk_file.endswith('.hkpckl'):
					hk_data = open(hk_file, 'r')
					bad_durations = pickle.load(hk_data)
					hk_data.close()
		
			record_index = 0      
			while record_index < number_records_toshow:
				
				##Import and parse binary
				record = f.read(record_size)
				try:
					particle_record = ParticleRecord(record, parameters['acq_rate'])
				except:
					print 'corrupt particle record'
					input("Press Enter to continue...")
					continue
				event_time = particle_record.timestamp
				
				###### FITTING AND ANALYSIS ########          
				number_bad_durations = len(bad_durations)
				
								
				#if there are any bad hk durations, note the beginning and end times of the first one
				if number_bad_durations:               
					bad_duration_start_time = bad_durations[0][0]#-parameters['timezone']  #needed timezone adjustemtn for 2010 data b/c the hk Bad durations lists were written in local time and I don't want to re-analyze them given the odd datestamping style
					bad_duration_end_time = bad_durations[0][1]#-parameters['timezone']
				
					#if the current event is after the end of the first bad duration in the list, pop that duration off, repeat if necessary until all bad durations before the event are gone
					while event_time >= bad_duration_end_time:
						if len(bad_durations): 
							bad_durations.pop(0)
							if len(bad_durations):
								bad_duration_start_time = bad_durations[0][0]#-parameters['timezone']
								bad_duration_end_time = bad_durations[0][1]#-parameters['timezone']
								continue
							else:
								break
				

				if not number_bad_durations or event_time < bad_duration_start_time:  

					#run the scatteringPeakInfo method to retrieve various peak attributes 
					particle_record.scatteringPeakInfo()
					actual_scat_signal = particle_record.getScatteringSignal()
					scattering_baseline = particle_record.scatteringBaseline
					actual_max_value = particle_record.scatteringMax
					actual_max_pos = particle_record.scatteringMaxPos
					
					#run the incandPeakInfo method to retrieve peak height
					particle_record.incandPeakInfo()
					incand_max = particle_record.incandMax
					

					#check to see if incandescence is negligible, scattering signal is over threshold, is in a reasonable position, and no double peaks
					if incand_max <= 5. and actual_max_value > min_peakheight and actual_max_value < max_peakheight and actual_max_pos > min_peakpos and actual_max_pos < max_peakpos:

						#particle_record.fullGaussFit()									
						fit_peak_pos = None# particle_record.FF_peak_pos
						fit_width = None#particle_record.FF_width
						fit_scattering_amp = None#particle_record.FF_scattering_amp
						zero_crossing_pt = None#particle_record.zeroCrossing()
						
						#plot particle fit if desired
						if show_full_fit == True:
							x_vals = particle_record.getAcqPoints()
							y_vals = particle_record.getScatteringSignal()
							fit_result = particle_record.FF_results
							print record_index
							
							fig = plt.figure()
							ax1 = fig.add_subplot(111)
							ax1.plot(x_vals,y_vals,'o', markerfacecolor='None')   
							ax1.plot(x_vals,fit_result, 'red')
							plt.show()
						
						
						for scat_amp in scat_amps:
							if scat_amp >= actual_max_value:
								AS_diameter = lookup_table[scat_amp]
								break
											
						
						#cursor.execute(('SELECT FF_scat_amp,UNIX_UTC_ts FROM polar6_calibration_data WHERE sp2b_file = %s and file_index =%s and UNIX_UTC_ts = %s'),(file,record_index,event_time))		
						#record = cursor.fetchall()
						#if record == []:
						data ={
						'sp2b_file' :file,
						'file_index' :record_index,
						'instrument' : instrument,
						'instrument_locn' :instrument_locn,
						'particle_type' :type_particle, 
						'UNIX_UTC_ts' : float(event_time), 
						'actual_scat_amp' :float(actual_max_value),
						'FF_scat_amp' :     fit_scattering_amp,
						'FF_peak_posn':     fit_peak_pos,
						'FF_gauss_width':   fit_width,
						'zero_crossing_pt': zero_crossing_pt,
						'particle_dia': AS_diameter,
						}
						#print file,record_index, actual_max_value,fit_scattering_amp
						try:
							cursor.execute(add_data, data)
							cnx.commit()
						except Exception, e:
							print 'error' % e
							print 'particle info', file,record_index,event_time
							#x_vals = particle_record.getAcqPoints()
							#y_vals = particle_record.getScatteringSignal()
							#fit_result = particle_record.FF_results
							#
							#fig = plt.figure()
							#ax1 = fig.add_subplot(111)
							#ax1.plot(x_vals,y_vals,'o', markerfacecolor='None')   
							#ax1.plot(x_vals,fit_result, 'red')
							#plt.show()
					
					
						

				record_index+=1   
					
			f.close()




os.chdir(data_dir)
for directory in os.listdir(data_dir):
	if os.path.isdir(directory) == True and directory.startswith('20'):
		parameters['folder']= directory
		folder_date = datetime.strptime(directory, '%Y%m%d')		
		if folder_date >= start_analysis_at and folder_date < end_analysis_at:
			parameters['directory']=os.path.abspath(directory)
			os.chdir(parameters['directory'])
			gaussFullFit(parameters)
			os.chdir(data_dir)
cnx.close()	



	

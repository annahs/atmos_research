#This script is for doing the leading edge fit on SP2 scattering signals 
#If run on non-incandescent particles, it can be used to check the performance of the LEO procedure (by plotting actual or FF scat amp vs LF scat amp)
#When run on incandescent particle it is used to recover the unperturbed peak scattering signal for coating determination
#The LEO_calibration_FF must be run before running this script to provide fixed fitting parameters for the appropriate instrument and time period ( beam width and center etc)

import sys
import os
import datetime
import pickle
import numpy as np
import matplotlib.pyplot as plt
from pprint import pprint
from scipy.optimize import curve_fit
from scipy import stats
from SP2_particle_record_UTC import ParticleRecord
from struct import *
import hk_new
import hk_new_no_ts_LEO
from scipy import linspace, polyval, polyfit, sqrt, stats
import math
from datetime import datetime
from datetime import timedelta
import calendar
import time
import mysql.connector


#analysis parameters
file = '20150128x004.sp2b'
data_dir = 'D:/2015/NETCARE_UBC_SP2/calibration data/20150128/'
os.chdir(data_dir)
data_file = data_dir + file   #'D:/2015/NETCARE_UBC_SP2/flight data/'#'D:/2012/WHI_UBCSP2/Binary/' #'D:/2012/WHI_UBCSP2/Binary/' #'D:/2009/WHI_ECSP2/Binary/'# 'D:/2010/WHI_ECSP2/Binary/'  #'D:/2012/WHI_UBCSP2/Binary/' 
instrument = 'UBCSP2'
instrument_locn = 'POLAR6'
type_particle = 'Aquadag' #PSL, nonincand, incand, Aquadag
num_records_to_analyse = 'all' #'all'
show_LEO_fit = False
FF = -2.7 #fudge factor for fit_width

#pararmeters used to assess incandescent peak
min_incand_amp = 20  #for 2015 polar6 flights an incand pk amp of 48 corresponds to a particle with BC mass of 0.25fg, which is ~65nm
min_LEOpos = 14 #need at least this number of points forthe fitting to work on
max_LEOpos = 100 #if the fit is using more than this number of points there is something fishy going on, (eg double peak)

#binary record size
record_size_bytes = 1498 #size of a single particle record in bytes(UBC_SP2 = 1498, EC_SP2 in 2009 and 2010 = 2458)

#database connection
cnx = mysql.connector.connect(user='root', password='Suresh15', host='localhost', database='black_carbon')
cursor = cnx.cursor()

#**********parameters dictionary**********
parameters = {
'acq_rate': 5000000,
}

f2 = open(data_file, 'rb')			
file_bytes = os.path.getsize(data_file) #size of entire file in bytes
number_of_records = (file_bytes/record_size_bytes)-1
if num_records_to_analyse == 'all':
	number_records_toshow =  number_of_records 
else:
	number_records_toshow = num_records_to_analyse    

#grab the pickled bad_durations file generated by the HK analysis
for hk_file in os.listdir('.'):
	if hk_file.endswith('.hkpckl'):
		hk_data = open(hk_file, 'r')
		bad_durations = pickle.load(hk_data)
		hk_data.close()

		
#**********calib parameters 
calib_start = 1422489600
calib_end = 1422576000

cursor.execute(('SELECT AVG(FF_gauss_width), AVG(actual_peak_posn), AVG(actual_zero_x_posn) FROM polar6_coating_2015 where UNIX_UTC_ts >= %s and UNIX_UTC_ts < %s and particle_type = %s and instrument = %s'),
	(calib_start,calib_end, 'PSL', instrument))	
calib_data = cursor.fetchall()
print calib_data
mean_calib_fit_width = calib_data[0][0]+FF
mean_peak_pos = calib_data[0][1]
mean_zero_x_posn = calib_data[0][2]
mean_zeroX_to_peak = mean_zero_x_posn-mean_peak_pos

#calculate half-width at x% point (eg 5% for factor 20)  
HWxM = math.sqrt(2*math.log(16))*(mean_calib_fit_width-FF)
mean_zeroX_to_LEO_limit = HWxM + mean_zeroX_to_peak

print mean_zeroX_to_LEO_limit,mean_zeroX_to_peak,mean_calib_fit_width


## fitting scattering signals to get info for LEO fits
record_index = 0
while record_index < number_records_toshow:
	
	##Import and parse binary
	record = f2.read(record_size_bytes)
	particle_record = ParticleRecord(record, parameters['acq_rate'])	
	event_time = particle_record.timestamp #UNIXts in UTC
	
	#**********************				
								
	#grab the pickled bad_durations file generated by the HK analysis
	for hk_file in os.listdir('.'):
		if hk_file.endswith('.hkpckl'):
			hk_data = open(hk_file, 'r')
			bad_durations = pickle.load(hk_data)
			hk_data.close()							
	
								
	#if there are any bad hk durations, note the beginning and end times of the first one
	number_bad_durations = len(bad_durations)
	if number_bad_durations:               
		bad_duration_start_time = bad_durations[0][0]
		bad_duration_end_time = bad_durations[0][1]
		#if the current event is after the end of the first bad duration in the list, pop that duration off, repeat if necessary until all bad durations before the event are gone
		while event_time >= bad_duration_end_time:
			if len(bad_durations): 
				bad_durations.pop(0)
				if len(bad_durations):
					bad_duration_start_time = bad_durations[0][0]
					bad_duration_end_time = bad_durations[0][1]
					continue
				else:
					break
	

	if not number_bad_durations or event_time < bad_duration_start_time: 

		#run the scatteringPeakInfo method to retrieve various peak attributes
		particle_record.scatteringPeakInfo()
		
		#get the zero-crossing with the appropriate method
		zero_crossing_pt = particle_record.zeroCrossing()
		analyze_this_particle = False
		
		
		particle_record.incandPeakInfo() #run the incandPeakInfo method to retrieve various incandescence peak attributes				
		incand_pk_amp = particle_record.incandMax					
		incand_pk_pos = particle_record.incandMaxPos
		scat_pk_pos = particle_record.scatteringMaxPos
		scat_max_amp = particle_record.scatteringMax
		
		if incand_pk_amp > min_incand_amp:		

			particle_record.leoGaussFit(mean_zeroX_to_LEO_limit,mean_zeroX_to_peak,mean_calib_fit_width)
								
			LEO_max_fit_index = particle_record.LF_max_index
			LEO_amp = particle_record.LF_scattering_amp	 #this will be -1 if the fitting failed, will be -2 if zero-crossing couldn't be found
			LEO_baseline = particle_record.LF_baseline #this will be -1 if the fitting failed, will be -2 if zero-crossing couldn't be found
			actual_baseline = particle_record.scatteringBaseline
			LF_percent_diff_baseline = np.absolute((LEO_baseline-actual_baseline)/(0.5*LEO_baseline+0.5*actual_baseline))
			
			if LEO_max_fit_index < min_LEOpos or LEO_max_fit_index > max_LEOpos: #error locating LEO fitting index
				LEO_amp = -3  #-2 in these values indicates a failure in the initial look for a zero-crossing, -3 indicates outside the range set here ie not enough data points for fitting
				LEO_baseline = -3
				
			cursor.execute(('UPDATE polar6_coating_2015 SET LF_scat_amp = %s, actual_scat_amp = %s WHERE sp2b_file = %s and file_index = %s'),(float(LEO_amp),float(scat_max_amp),file,record_index))		
			cnx.commit()
					
		
			
			###########
			#plot particle fit if desired				
			if show_LEO_fit == True :#and incand_pk_amp > 1300:
			
				x_vals_all = particle_record.getAcqPoints()
				y_vals_all = particle_record.getScatteringSignal()	
				y_vals_split = particle_record.getSplitDetectorSignal()
				y_vals_incand = particle_record.getWidebandIncandSignal()
				fit_result = particle_record.LF_results		
				print file, 'record: ',record_index, LEO_amp, scat_max_amp
				#print  'core VED', ((((0.00202*incand_pk_amp+0.15284)/(10**15*1.8))*6/3.14159)**(1/3.0))*10**7
				fig = plt.figure()
				ax1 = fig.add_subplot(111)
				ax1.plot(x_vals_all,y_vals_all,'o', markerfacecolor='None')  
				try:
					ax1.plot(x_vals_all,fit_result, 'blue')
				except:
					print 'no fit result'
				ax1.plot(particle_record.LF_x_vals_to_use,particle_record.LF_y_vals_to_use, color = 'black',linewidth=3)
				#ax1.plot(x_vals_all, y_vals_split, 'o', color ='green')
				ax1.plot(x_vals_all, y_vals_incand, color ='red')
				plt.axvline(x=zero_crossing_pt, ymin=0, ymax=1)
				plt.axvline(x=particle_record.beam_center_pos, ymin=0, ymax=1, color='red')
				plt.show()
			################
		
	
	if (record_index % 1000) == 0:
		print 'record: ', record_index
		
	record_index+=1    
f2.close()  	


cnx.close()	




